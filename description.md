
# 数据结构与算法：
目前，计算机已经深入社会生活的每个领域，其应用已经不再仅限于科学计算，更多的是用于控制和管理及数据处理等非数值计算领域；     
计算机科学是一门研究用计算机进行信息表示和处理的科学；    
## 信息表示：
信息在计算机中的表示形式；   
比如，如何在计算机中保存一张图片，一部电影等；  
## 信息处理：
信息处理指计算机对信息的处理过程。  
信息的表示和组织又直接关系到处理信息的程序的效率；    

随着应用问题的不断复杂，导致信息量剧增与信息范围的拓宽，因此许多系统程序和应用程序的规模都很大，结构又相当的复杂；    
因此，要求首先对待处理的问题进行分析；    
我们要分析问题中的对象的特征及各对象之间存在的关系，这就是数据结构这门课所要研究的问题；   
首先，我们要了解数据结构中常用的概念和术语：    
 数据；   
数据元素；   
数据对象；    


### 数据结构中常用的概念和术语：

#### 数据：
数据是信息的载体，是能够被计算机识别、存储、计算（处理）的符号集合，是计算机处理的对象的总称；

##### 注意三点：
 识别、存储、计算。凡是符合这三点的符合集合都可以称之为数据；   
在计算机语言中，数据的含义非常广泛，除了通常使用的数字、字符串以外，任何能够被输入到计算机，并且能够被处理的符号，都可以称之为数据。   
例如，一个学生的姓名、身高、体重、肤色、声音可以被称作数据；   
一张图片、一部影音文件等也可称作数据。      

#### 数据元素：
数据元素也称为结点，是组成数据的基本单位。   
举例：    
假如，我们把一次所有学生的考试成绩当做一个数据，那么这次考试成绩当中一个学生的考试成绩就是一个数据元素；    

但是，数据元素不是数据的最小单位，数据元素又可再分，数据元素又可以由若干数据项组成。这些数据项也称之为字段、域、属性。    
数据元素又由若干数据项组成。    

##### 数据项：
数据项是数据的最小单位；   
数据项具有原子性，不可分割；    

举例：     
在一个交易系统中，我们把所有的交易信息称之为数据，那么这些交易信息中一条交易信息就是一个数据元素。     
这条交易信息中的交易号、交易金额等就是这个数据元素的数据项。      

数据、数据元素和数据项，是三级关系。      
数据是最顶的一级，数据元素是次一级，而数据项是最小一级。     

##### 数据、数据元素和数据项的区别是：   
- 数据是一个统称，所有能够被计算机识别的符号集合都算数据。    
- 数据元素是数据的一个节点，它是被包含的关系。也就是说，数据中包含数据元素。     
- 数据项是数据元素的一个节点，也就是说数据元素又包含数据项。
- 数据项是数据的最小单位，不可再分割了；

### 数据对象：
数据对象是具有相同特征的数据元素的集合，它是数据的子集。  
强调点：相同特征、数据元素、集合。   
数据对象是数据的子集。    
数据元素是数据的子集，数据对象也是数据的子集。但是，数据对象是具有相同特征的数据元素的集合。它是数据元素的集合，同时它又是数据的子集；      
数据对象和数据元素都是数据的子集，它们之间没有冲突。      
举例：    
一个班全体学生的成绩表就是一个数据对象，这个班全体学生的家庭住址也是一个数据对象。   
我们把所有学生的学习成绩当做数据，那么每个学生的学习成绩是一个数据元素。但是，每个学生都在不同班级；我们在这个班级的所有学生学习成绩当做一个数据对象。   
这就是数据、数据对象和数据元素之间的关系。   

#### 数据结构：
数据结构是计算机存储、组织数据的方式；它描述了数据元素之间的相互关系，以及数据元素的组织形式。    
也就是说，数据结构描述了数据元素之间的相互关系，和数据元素的组织形式。     
首先介绍：      
逻辑结构；    
存储结构；     
数据运算；       

### 逻辑结构：
数据的逻辑结构是指从逻辑关系上描述数据，与数据的存储无关，且独立于语言。     
也就是说，数据的逻辑结构，仅仅是从数据的逻辑关系上研究问题，它不会管数据存储在哪儿，也不会管怎么存储，这些都不会管；      
举例：      
有一个成绩表，先来看下这个成绩单中各条数据之间的联系。       
这个成绩单是按学号排序的，这个班里只有六个人，因此，学号是从01到06，成绩单第一行是学号末位为01的学生成绩，它在这个成绩单中就是这个表的起始数据，最后一行学号末位为06，这行数据就是终止数据；        
同时，每个学号只有一个前排名学号，和一个后排名学号；       
这个班里只有六个人，学号是从01到06，不可能有两个学号是相同的，因此只要把这些学号做排名，那么，它的每个学号只有一个前排名学号和一个后排名学号；比如，学号末位为02，这行记录的前排名学号是01，后排名学号是03；整个成绩单就是这个样子的；       
这个样子，这些数据之间的关系，是逻辑关系，因此，这些就是成绩表的逻辑结构。它与每条记录的存储位置没有关系；       
也就是说，它是你用word存储的，还是用excel存储的，没有关系，它不管这些，也就是说，逻辑结构独立于语言。       


#### 存储结构：
数据的存储结构是指数据元素及其关系在计算机存储时如何表示，依赖于语言。     
举例：     
还是刚才的成绩单；现在，我打算将这个成绩单存入计算机，因此现在我就必须考虑存储结构了；我们程序设计时，通常是用一个结构数组来存储整个成绩表的，每个数组的元素就是一个结构；每个数组元素对应于成绩表中的一个结点；也就是说，它对应成绩表中一条记录，即对应一个人的成绩信息。    
也就是说，每个学生的成绩信息存储在计算机中一个结构数组的一个数组元素中。因此，数据在计算机的存储方式就是存储结构。它依赖于语言。      
  
#### 分析一下逻辑结构和存储结构，看看它们之间的区别：
逻辑结构仅仅是从逻辑关系上描述数据的，它与数据在计算机内存中的存储位置没有一点关系。也就是说，它只是从逻辑关系上描述数据，但是数据具体在计算机内存中的存储位置，就说你数据存在哪儿，是怎么存的，是顺序存储的还是链式存储的，它不管；         
##### 存储结构则正好相反；
存储结构是根据数据元素在计算机存储时，数据之间的存储位置和关系来描述数据的；那么，这个就是存储结构；      
存储结构和逻辑结构之间的区别就是这样的；     
逻辑结构是独立于语言的，而存储结构是依赖于语言的；      

逻辑关系表示数据的逻辑关系，存储结构表示数据的存储关系；      
这两个概念是从两个角度对数据的描述。      
我们学习数据结构的目的是为了更好的处理数据，因此还要了解数据运算；     

#### 数据运算：
数据运算通常定义在数据的逻辑结构上，每种逻辑结构都有一个运算的集合，但运算的具体实现要在存储结构上进行；       

举例：      
还是刚才的成绩表；       
表中每一行是一个数据元素，也称之为节点；成绩表是以学号排序的，所以第一个学号所在的那行是开始节点，最后一个学号所在行是终端节点；每一行的前一行是它的前趋，后一行是它的后继。成绩表中任意一个节点，与它相邻并且在它前面的节点最多只有一个，相邻并且在它后面的节点也只有一个，这就是一个线性的逻辑结构，也就是从逻辑结构上描述这个表。      
如果每行数据在内存中顺序邻接地存储，这个表就是顺序存储结构；       
##### 这是从存储结构上描述这个表；    
现在，我要在成绩表的最后一条的记录下面增加一个学生的成绩。    
增加操作的定义是什么呢？       
##### 我们要给出一个增加操作定义；
增加操作的定义就是我们把新增加这一条记录作为新的终端节点，并且原来最后一个学号所在的行，那个终端节点成为新增这一条学生记录的前趋节点。       
新增的学生记录成为原来最后一个学号所在的行所在节点的后继节点；       
这是增加操作的定义；       
这个定义的具体实现呢，也就是说这个表在内存镇南关是属性邻接地存储的，那么我新增一条记录就需要在内存中顺序邻接的新增一个存储地址，存储我们新增加的学生的学习成绩信息。       

也就是，数据运算，它的实现是在存储结构上进行的；        
数据运算通常定义在数据的逻辑结构上，实现要在存储结构上进行。      
对表中数据的增、删、改、查等操作都是数据运算。       

##### 深入的学习一下数据的逻辑结构：
数据的逻辑结构按照数据元素之间的相互关系，又可以分为线性结构和非线性结构；      
### 线性结构：
线性结构是指有且仅有一个开始节点和一个终端节点；    
所有节点都最多只有一个直接前趋和一个直接后继。    
那么这样的结构就是线性结构；        
举例：      
线性表，栈，就是线性结构；     
### 线性表和栈的结构：
- 线性表：    
线性表仅有一个开始节点；同时，它也只有一个终端节点；      
- 栈：
栈只有一个栈顶和一个栈底；因此，它只有一个开始节点和一个终端节点；    
- 线性表和栈存储元素的存储关系：
线性表和栈的存储元素也是一个线性关系，就像线性表的1节点，1节点的后续节点是2节点，2节点的后续节点是3节点，3节点的后续节点是4节点；    
它是这样的一个线性的关系；   
因此所有的节点最多只有一个直接前趋和一个直接后继。      
因此，线性结构就是指有且仅有一个开始节点和一个终端节点，并且所有节点最多只有一个直接前趋和一个直接后继；这样的结构就是一个线性结构；      

### 非线性结构：
非线性结构是指一个节点可能有多个直接前趋和直接后继。    
举例：    
树，图 就是非线性结构；     
### 树和图的结构：
- 树：
在树上面，有一个根节点，节点1，称之为节点1为根节点，在这个根节点下面，还有两个子节点2和3；同样，在2节点下面又有两个子节点4和5，在3节点下面有一个子节点节点6；因此，它的每一个节点都有多个直接后继；比如，根节点1有两个后继节点2和3；    
- 图：
图没有根节点，也没有终端节点，像这样的称之为闭合树；     
从1节点说起，1节点有两个后续节点2和3,；同样的，2节点也有两个后续节点1和4；3有两个后续节点1和4；4有两个后续节点3和2；        
同样，图也是一个节点可能有多个直接前趋和直接后继；        
像树和图这样的就叫非线性结构；      
##### 因此，非线性结构的定义就是指：
一个节点可能有多个直接前趋和多个直接后继，这样的结构就叫非线性结构；        

当我们学习了数据的逻辑结构的线性结构和非线性结构，尤其看了树和图，就会想，树既然是数据结构中的一种结构，那么假如我想在树中查找某个节点应该怎么做呢？就要涉及数据结构中的另外两个重要的概念：**算法和算法分析**；        

## 算法和算法分析：
算法：     
算法是为求解一个问题需要遵循的、被清晰地指定的简单指令的集合。    
算法是一个指令的集合。     
算法通常以某一个数据集合作为输入，执行完一组特定的指令之后，返回一个唯一的数据集合作为输出。     

举例：       
我们打算去迪拜旅游，我们首先要先定旅行社，然后根据谈妥的价钱去银行给旅行社打钱，然后旅行社才会送我们去旅游，再接着我们才能到达迪拜同时欣赏迪拜的美景与美女；旅游完了，旅行社会送我们回来；这些，就可以用算法来表示，输入和输出都是我们，算法的执行过程就是我们旅游的过程。     

### 正确的算法具有以下几个特点：
##### 第一：       
用待处理问题的相关信息作为输入数据；    
要去旅游的人是我们，因此输入是我们；    
##### 第二：     
对一个既定的合法输入，多次执行同一个算法，总是返回同一个结果（随机算法除外）；   
我们要去旅游，不论我们去多少次，旅游回来的人肯定还是我们；    
##### 第三：
算法中的指令是可行的；    
即每个指令都可以实现，并且在有限的时间内完成。     
我们定旅行社也好，交费也好，全部都是实际的行动。都是有时间限制的。     
##### 第四：
算法中指令的数量是有限的；   
即在有限的时间内，算法可以正确结束，不能无限循环下去；     
也就是说，我们旅游总有旅游结束的时候，不能赖在迪拜不走了，其结果肯定是有人赶你回来；    
##### 第五：
算法执行完毕后，能够输出正确的数据集合。     
我们旅游肯定是寻求安全的旅行社，因此旅游结束了肯定希望要安安全全地回来；     


### 正确的算法具有以下几个特点：
##### 第一：    
用待处理问题的相关信息作为输入数据；    
##### 第二：
对一个既定的合法输入，多次执行同一个算法，总是返回同一个结果（随机算法除外）；    
##### 第三：
算法中的指令是可行的；    
即每个指令都可以实现，并且在有限的时间内完成。      
##### 第四：
算法中指令的数量是有限的；    
即在有限的时间内，算法可以正确结束，不能无限循环下去；     
##### 第五：
算法执行完毕后，能够输出正确的数据集合。    

### 算法分析：
同一问题可用不同算法解决，一个算法的效率会影响程序的效率；   
算法分析的目的在于选择合适的算法，算法分析是从复杂度来考虑的；   

#### 复杂度：
复杂度是衡量一个算法好坏的重要手段，复杂度分为时间复杂度和空间复杂度；   
##### 时间复杂度：
时间复杂度以一个算法执行的时间长短衡量一个算法的优劣。如果问题规模是n，则时间复杂度是n的一个函数，记做  `T(n)=O(f(n))`    

##### 如何估算算法的时间复杂度：
刚才说了，算法是一个指令集合，算法包括控制结构指令和操作指令；   
也就是说，算法是循环跳转判断指令和数据的操作指令的集合。    
可以得出一个结论：         
```
算法的执行时间 = 算法的循环次数  &#42; 操作执行的时间。
```
由此可以看出算法执行时间和算法循环次数（操作执行次数之和）是成正比的；    

示例：   
```
for (int i=0; i<=n; i++)
```
这个算法的时间复杂度就是 O(n) ； 因为它循环了n次；    

示例：    
```
for (int i=0; i<=2n; i++)
```
这个算法的时间复杂度是 O(2n) ；

### 空间复杂度：
空间复杂度以一个算法执行过程中所要占用的存储空间多少来衡量一个算法的优劣。它也是问题规模n的一个函数。记做` S(n) = O(f(n))`

空间复杂度的概念和时间复杂度类似，都不是以算法的绝对执行时间和绝对使用空间来计算的。
空间复杂度是额外消耗的存储空间，并不包含算法加载时占用的存储空间；     
举例：       
比如一个插入排序算法，最终只插入一个值，额外消耗了一个存储空间，因此空间复杂度就是 O(1) ；     

复杂度越高，算法执行效率越低，算法也就越差。    
因此，复杂度是算法优劣判断的标准。    


## 线性表：
线性表是最基本、最简单、也是最常用的一种数据结构。   
线性表中各数据元素之间的关系是一对一的关系，也就是说在线性表中除了第一个和最后一个数据元素，其他的数据元素都是首尾相接的。   

线性表是由`n(n>=0)`个数据元素（节点）组成的有限序列。   

由此可见线性表的逻辑结构非常简单，非常容易实现和操作。     
因此，线性表这种数据结构在实际应用中是广泛采用的一种数据结构。     
但是在实际应用中，线性表是以栈、队列、字符串、数组等特殊线性表的形式来使用的，不是被直接使用的；     
由于这些特殊的线性表都具有各自的特性，但是它们毕竟都是线性表，因此，掌握基础线性表的特性，对于将来数据运算的可靠性和提高操作效率都是至关重要的。所以，基础线性表是至关重要的；    
### 线性表的特点：
第一：    
有且仅有一个开始节点；     
第二：     
有且仅有一个终结节点；     
第三：     
线性表内部节点都有且仅有一个直接前趋节点和一个直接后继节点；      

除了上述特点，线性表还要有均匀性和有序性的特点，均匀性和有序性也是在这三个特点之上总结起来的；      
均匀性是指虽然不同数据表的数据元素可以是各种各样的，但是对于同一线性表的各数据元素必定具有相同的数据类型。      
有序性是指各数据元素在线性表中的位置只取决于它们的序列，数据元素之间的相对位置是线性的；     

举例：     
学生成绩表就是一个线性表。       
当我们创建一个学生表的时候，需要把第一个学号放在表的第一行，也就是先输入学号尾数为001的学生的信息，那么这条记录就是线性表的开始节点；然后我们要紧接着输入第二个学号尾数为002的学生的成绩信息。紧接着再输入尾号为003的学生成绩信息。。再然后是尾号为004的学生成绩信息。最后输入005的学生成绩信息，005是最后一个学生。因此学生成绩表到此也就结束了，005节点就是成绩表的终结节点；         
判断一个数据结构是不是线性表，只要拿线性表的三个特点一个一个核对下就可以判断出来；     
首先看这个成绩表只有一个开始节点即“尾数为001的学号记录”，同样终结节点也只有一个“尾数为005”，而学生成绩表内部学号都是按顺序排序的，也就是一个接一个，每个学生只有一个前趋节点和一个后继节点；所以，它是一个线性表；         
对于一个成绩表，我们可以查询某个学生的成绩，我们可以在成绩表里加入一个学生的成绩，修改一个学生的成绩，同样也可以删除一个学生的成绩；因此，线性表有查询、插入、修改、删除等操作；程序如果要定义一个线性表操作的接口就需要定义这些操作；         
示例：     
```java
 //线性表接口
public interface LinearList {
 boolean isEmpty();
 int size();
 E get(int index);
 E set(int index,Object e);
 boolean add(int index,Object e);
 boolean add(Object e);
 E remove(int index);
 void clear();
}
```
在这个示例中，首先定义了接口类名，然后接口类里定义了判断线性表是否为空的方法`isEmpty()`方法，定义了线性表查询的`get()`方法，定义了线性表替换元素的`set()`方法，定义了线性表插入操作的`add()`方法，定义了线性表删除元素的`remove()`方法，定义了线性表清除所有元素的`clear()`方法；      
这样的一个线性表接口，才能基本上实现对线性表的操作。    
有了这个接口之后，接下来看一下线性表的存储。    

### 顺序存储：
数据结构包括逻辑结构、存储结构和数据运算。    
前面都是从逻辑结构上对线性表的分析，接下来我们要从存储结构和数据运算上分析线性表。线性表分为顺序存储和链式存储两种实现方式。    
#### 首先看一下线性表的顺序存储：
- 线性表的顺序存储：
线性表的顺序存储也称为向量存储，可以看做是一维数组存储。也就是用一组连续的内存单元依次存放数据元素；数据元素在内存的物理存储次序与它在线性表中的逻辑次序相同。     
举例：     
我们要创建一个顺序存储的线性表，首先在计算机中分配一组连续的内存单元，然后在第一个单元放入线性表第一个数据元素a[0]，接着在第二个单位放入线性表的第二个数据元素a[1]，在第三个单元放入线性表的第三个数据元素a[2]，在第四个单位放入线性表第四个数据元素a[3]，一直继续下去直到a[n]。      
数据元素在内存的物理存储次序跟它们在线性表中的逻辑次序相同。    
##### 由此可见，顺序存储的特点是：  
第一：     
使用连续的内存单元存放线性表的数据元素，它的内存单元是连续的。    
第二：     
数据元素在内存中的物理存储次序与它们在线性表中的逻辑次序相同。     

顺序存储的线性表的优点很明显同样缺点也很明显。     
优点是存储密度大，因为存储单位的位置是连续的，几乎不浪费空间。      
缺点是插入、删除等运算都不方便。原因是我们如果在线性表中间插入一个数据元素，那么这个数据元素之后的所有元素的存储位置都需要发生变化。都要后挪一个位置，才能重新生成一个完整的线性表。           

对一个顺序存储的线性表，如何对其进行排序，排序的结果就是数组内的数据从小到大？       
这就要用到选择排序；      
#### 选择排序的定义：
首先，遍历线性表并将最小的元素与第一个元素进行交换。     
随后遍历剩余的元素将第二小的元素与第二个元素进行交换，依此类推直至排序结束。    

示例：     
```
横排排序序列   23 45 16 7 42
```
首先，有一个待排序数组序列` "23 45 16 7 42"` 。这是一个乱序数组。       
#### 什么是乱序数组：
乱序就是没有特定的顺序。     
这个数组不是从小到大也不是从大到小，因此它是一个乱序数组；   
现在就要给它理出一个次序出来，所以我们才进行排序；    
在实际的应用中对数据进行整理，进行排序的数据运算是很常见的。     
下面来使用选择排序的方法对这个数组进行排序。     
排序的结果就是数组里的元素按从小到大的顺序排列；    

选择排序的第一步，我们首先要遍历这个数组，也就是说我们要从数组的第一个元素一直遍历，直到最后，这样是可以从数组序列中，查找到最小元素的，最小的元素是7.我们找到这个数组的最小元素是7，然后拿7元素与第一个元素23交换，交换的结果生成了一个新的数组序列 `7 45 16 23 42`
接下来选择排序的第二步，从数组序列的第二个元素开始遍历直到最后，在遍历的所有元素中再次查找最小的元素。换个说法就是查找整个数组的第二小的元素，这次找到了16，然后把16元素与第二个元素45交换。         
交换的结果又生成了一个新的数组序列 `7 16 45 23 42`     
选择排序的第三步，从剩余元素中再次查找最小的元素，这次查找的结果是23，然后23元素与第三个元素45交换。       
再次得到一个新的数组序列` 7 16 23 45 42`       
选择排序的第四步，继续从剩余元素中查找最小的元素42,45与42交换位置，再次得到一个新的数组序列 `7 16 23 42 45 `         
现在后面还剩最后一个元素45，已经没有与它可相比较的元素了，到此完成排序。那么对这个数组进行选择排序的最终结果就是 `7 16 23 42 45`         

我们知道了线性表的顺序存储，接下来学习线性表的链式存储。    
#### 线性表的链式存储：
- 链式存储的定义：       
链式存储用若干地址分散的存储单元存储数据元素，逻辑上相邻的数据元素在物理位置上不一定相邻，必须采用附加信息表示数据元素之间的关系。     
即用指针来体现节点之间的逻辑关系。     
线性表链式存储就是说用一组地址任意的存储单元存储线性表的数据元素。      
即：其中节点的逻辑次序和物理次序不一定相同。      
线性表的顺序存储是分配的一个连续的存储空间，例如数组，我们插入元素或者查询元素的时候，只要按顺序下一个就能够遍历整个线性表。       
但是链式存储的线性表不同，因为他的存储单元的地址是分散的，而逻辑关系上却又是连续的。   
我们说，一个线性表的数据元素在内存中，数据元素是分散的，为了表示这些数据元素是一个线性表并且还要表示出其中数据元素之间的先后关系，我们需要对线性表进行特殊处理，所以我们在每个节点上，就需要一个附加信息，就是一个指针，它指向这个元素的后续节点的地址位置，根据这个指针，我们才能完全遍历这个线性表。这样的线性表就是线性表的链式存储。       
##### 链式存储的线性表又分为：
```
单链表、
循环链表、
双链表。
```
- 单链表：    
单链表也叫线性链表，是由一个个节点链接而成。单链表的每个节点中只有一个存放数据的数据域和一个称为next的指向后续节点的指针域。    

就是因为它的每个节点中只有一个next指针域，并且它也不是闭环的，它是一条链状结构，因此才被称为单链表。单链表是最简单的链式存储的线性表，它就像一条链子，它的每个节点都可以分为两部分，一个是数据域(nodeValue)，一个是指针域(next)；数据域存储节点的数据，指针域指向下一个节点的内存存储地址。      

下面我们从逻辑结构和存储结构上，来分别分析链式表；      
假如我们有一个单链表，它的头节点是k1，k1的next指针指向k2,也就是说k2是k1的后继节点，k2的next指针又指向k3，也就是说k3是k2后继节点，k3的next指针又指向k4，同样k4是k3的后继节点，k4的next指针指向k5，这样k5也就是k4的后继节点；     
这个就是单链表的逻辑结构；    
这个单链表在计算机的存储结构如图：    
``` 
存储地址       info        next
1000
1001           k1          1003
1002
1003           k2          1007
1004   
1005           k4          1006
1006           k5          null
1007           k3          1005
```

k1的next指针域里存储的指针是1003,1003是一个内存存储地址；根据1003可以找到k2节点，k2节点的next指针域里存储的是1007，同样根据1007这个内存存储地址又可以找到k3节点，k3的next指针域里存储的是1005，根据1005又找到了k4节点，k4的next指针域里存储的是1006，根据1006又找到了k5节点，k5的next指针域是空，因此单链表到此结束。    
因此对于单链表，我们还需要知道两个概念，头指针和空指针；       
头指针是指单链表第一个节点存储的位置，它是一个指针，它指向单链表第一个节点存储的位置；      
整个单链表的存储必须从头指针开始，我们常用head表示；    

单链表是一种特殊的线性表，因此它的主要操作跟线性表是一样的，需要查询、插入、删除和清除等操作；     
我们以插入操作来举例：       
插入操作可以非常形象的用十字路口堵车后，一排小汽车突然又新来了一辆汽车来加塞来形容；本来相连的两辆汽车是有关系的，它们之间什么关系呢？      
也就是后面的一辆汽车的驾驶员眼里看着前面一辆汽车，那么我们假设他眼里存着前面一辆汽车的车牌号，现在有辆车来加塞，那么后面的驾驶员眼里就不能再存前面这辆汽车的车牌号了，而是改为了加塞车的车牌号，而加塞车的驾驶员眼里反而存上了前面那辆汽车的车牌号。这样就变成了一个新的单链表；         
因此，单链表的操作实现与顺序存储的线性表接口实现是有区别的；它多了指针的处理，因此我们需要重新定义单链表操作接口实现。       

### 循环链表：
循环链表是线性表的另外一种链式存储结构，它在单链表的基础上，将表尾节点的指针域指向表头节点，整个链表形成环状结构。     
##### 注意定义中的三个要点：     
- 第一：它是线性表；
- 第二：它跟单链表类似；   
也就是说，循环链表也是由一个一个的节点链接起来的；    
- 第三：它跟单链表又有区别；
它将单链表表尾节点的指针，也就是单链表最后一个节点的指针域中的指针指向了单链表的表头节点，这样一个单链表就变成了循环链表。     
单链表最后一个节点的指针域是空，最后如果把next指针指向单链表的开头节点，这样的一个单链表就变成了循环链表。       
**需要注意**：     
循环链表也有head属性，head属性是一个指针，它单独指向头节点；    
判断一个循环链表是不是空链表的条件就是` head==head->next`     
也就是head指向节点的下一个节点还是head指针，这就说明循环链表里没有节点，这就是一个空链表；         
循环链表相当于在圆形跑道上的一圈小汽车，首尾相接，每一辆汽车的驾驶员看着前面的那辆汽车，相当于眼里存着前一辆汽车的车牌号，那么这一圈小汽车形成一个环形结构。        
循环链表仅仅把单链表做了首尾相接；      

### 双链表：
双链表是可以同时在向前和向后两个方向上查找数据元素的单链表。它的节点除了数据域之外，还有previous和next两个指针域，这两个指针域分别指向直接前趋节点和直接后继节点；
双向链表跟循环链表类似，都是在单链表基础上做了复杂化处理的结构。      

#### 顺序查找：
前面介绍完了线性表的链式存储。    
现在有个问题，我们有值"S"，现在需要在链式存储的线性表中查找数据域存储值为"S"的记录，应该怎么办？      
需要从线性表的一端开始，逐个把线性表中每个节点的数据域存储的值和"S"做比较，直到找到等于"S"的记录，或者到达线性表的另一端。     
这就是线性表顺序查找算法的基本原理；     
顺序查找算法可以采用从前往后查，也可以采用从后往前查的方法。     
说明：     
在平均情况下，顺序查找大约需要与表中的一半元素进行比较才能查找到匹配的关键字；     

### 栈：
栈的中文解释是存储货物的物件或供旅客住宿的房屋。以存储货物的物件来说明，那么这些存储货物的物件都有什么特点吗？   
这些物件都只有一个入口才能存得了东西，比如一个水桶，假如下面在开一个口，那水就都流走了；水倒进水桶，然后倒出的时候是最后进去的那部分水先倒出来；   

#### 栈的定义：
栈：    
栈也叫堆栈，是一种限制只能在某一端进行插入和删除操作的线性表。   

它是一种受限制的线性表，只能在线性表的某一端进行插入和删除操作。   
允许插入和删除的一端称为栈顶，相反，另外一端称为栈底；    
存储在栈顶位置的数据元素称为栈顶元素。   
存储在栈底位置的数据元素称为栈底元素；     
不包含任何数据元素的栈称为空栈；    
对栈进行操作，插入一般称为进栈。    
删除则称为退栈，也叫出栈。    
访问栈中的元素时，遵守后进先出(LITO)的运算规则。    
因此，栈也称为后进先出表；      

在计算机系统中，栈是具有这些属性的动态内存区域。    
程序可以将数据压入栈中，也可以将数据从栈顶弹出。      
在i386机器中，栈顶是由一个称为esp的寄存器进行定位的，压栈的操作使得栈顶的地址减小，弹出的操作使得栈顶的地址增长。栈在程序的运行中有着举足轻重的作用。最重要的是栈保存了一个函数调用时所需要的维护信息。这些通常称之为堆栈帧或者活动记录。堆栈帧一般包含函数的返回地址、参数和临时变量等。      
因此，栈非常重要；     

栈是一种特殊的线性表，因此我们要定义一个栈操作的接口就需要在接口中体现栈的特性。在这里有一个栈的接口代码示例，首先在这个接口代码示例中，定义了栈的操作接口代码的类名，然后紧接着在接口类里面，定义了一些栈的基本操作方法；   
``` 
push()方法用于向栈内压入值；    
pop()方法用于弹出栈顶的值，即返回栈顶的值，并把它从栈内删除；
peek()方法用于查询栈顶的值，即只返回但不删除栈顶；
isEmpty()方法则用于判断这个栈是否为空栈；
size()方法返回栈的大小；
```
```java
//栈的基本操作接口
package com;

public interface Stack {
 public void push(Object e);
 public E pop();
 public E peek();
 public boolean isEmpty();
 public int size();
}
```

这些方法体现了我们对栈的基本操作；由此可知，栈的基本操作，包含进栈操作、出栈操作、查询操作和判断栈是否为空的判断操作，查询栈大小的查询操作；这些就是栈的基本操作；     

知道了栈的基本操作，下面我们来具体学习栈，栈又可分为顺序栈和链栈。   

### 顺序栈：
栈的顺序存储结构简称为顺序栈；   
顺序栈用一组连续的存储单元依次存放从栈底到栈顶的数据元素；同时用一个指针top指针指示栈顶元素在顺序栈中的位置。    
关键：     
顺序栈是用一组连续的存储单元，来存放从栈底到栈顶的数据元素的；   
那么我们从逻辑结构和存储结构上来分析顺序栈：       
首先，从逻辑结构上来说，顺序栈也是栈的一种，因此首先它要有栈的特性，因此它只能在一端进行插入和删除操作；     
其次，从存储结构上来说，顺序栈要用一组连续的存储单元依次存放数据元素；     
##### 由此可见，顺序栈有3个特点：
第一点：     
数据元素存放在连续的存储地址中；（这是从存储结构上来说的）     
第二点：      
栈底位置固定不变；    
因为栈只能在一端进行插入和删除操作，而进行插入和删除操作的一端称为栈顶；另外一端称为栈底，因此栈底位置是固定不变的；    
第三点：     
栈顶位置随进栈、出栈操作而变化；     

示例：     
现在有一个符号对平衡需求，输入一个表达式（字符串），顺序读取表达式字符当遇到`"{" "[" "(" 则压入栈，当遇到 ")" "]" "}"` 则进行出栈操作；      
因此，这个需求里首先要定义一个栈，然后再根据表达式、顺序读取的字符去做判断，是做入栈操作还是做出栈操作；      
并且这个需求的关键是做比较看是否配对，配对则说明是符号对平衡，否则符号对不平衡。 看演示视频；     

### 队列：
队列的定义：    
队列也叫队，是允许在一端进行插入，而在另一端进行删除的运算受限的线性表。   
删除数据的一端称为队头(front)；    
插入数据的一端称为队尾(rear)；     
队头的数据元素称为队头元素，队尾的数据元素称为队尾元素；    
假如一个队列，在这个队列中没有任何数据元素的队列称为空队列，空队列的条件是 `front==rear` ；        
访问队列中的元素遵循先进先出(FIFO)的运算规则；     
队头的元素最先进入队列，也最早被删除；      
队头元素被删除以后，其后继元素成为新的队头元素；     
在队尾添加新的数据元素，新元素将成为新的队尾元素；     
队列按照存储方式的不同，可分为顺序队列和链式队列；      

#### 队列的操作：
队列也是一种特殊的受限制的线性表，因此它也有插入和删除等操作，但是队列的插入和删除操作和栈又是完全不同；    
栈是后进先出的，队列是先进先出的，因此我们以一个新的队列操作的接口示例来说明队列的基本操作；    
示例：   
```java
//队列的基本操作接口
package com;

public interface Queue {
 public void push(Object e);
 public E pop();
 public E peek();
 public boolean isEmpty();
 public int size();
}
```

在这个接口示例中，我们首先要定义队列接口操作的类名，在接口操作类里定义了一些队列接口操作的方法；    
```     
其中，push()方法用于向队列的队尾插入值；
pop()方法用于弹出队列队头的值，即返回队头的值，并把它从队列内删除；
peek()方法用于查询队列队头的值，即只返回但不删除队头；
isEmpty()方法用于判断是否为空队列；如果队列是空队列，则返回true；否则，返回false；
size()方法返回队列的大小；
```
这个就是队列的接口代码示例，这个接口代码示例包含了对队列的基本操作；因此，对队列的基本操作有，插入操作（即入队操作），出队操作，查询操作，判断是否为空的操作，查询队列大小的操作；   


#### 顺序队列：
队列的顺序存储结构称为顺序队列，与顺序栈一样，顺序队列也是用一组地址连续的存储空间存放队列中的数据元素，并使用front和rear两个指针分别指示队头元素和队尾元素的位置。    
顺序队列只能从队头（front端）删除元素，向队尾（rear端）添加新元素；    
##### 关键：      
顺序队列是用一组连续的存储空间来存放队列中的数据元素的，顺序队列是队列的一种，它具有队列的特征，队列的特征就是只能在队列的一端插入元素，在另一端删除元素，因此顺序队列只能从队头（front端）删除元素，向队尾（rear端）添加新元素。     
顺序队列除了具有队列的特征之外，更关键的是它在存储结构上，它有自己的特点，特点是用一组地址连续的存储空间来存放队列中的数据元素，因此被称之为顺序队列；    

示例：    
我们先创建一个空队列，空队列的条件是front等于rear，并且front和rear都指向0地址；现在把	A B C三个数据元素入队，队列的入队结果是：front指针还是指向队头0地址，而rear指针则指向了队尾3地址。同时队列里0地址存放A，1地址存放B，2地址存放C。接着把A出队，front指针发生了变化，front指针指向了1地址，同时0地址存储的A元素已经被删除。     
现在我们继续把B元素和C元素同时做出队操作，出队的结果是：队列变成一个空队列；空队列的条件是front=rear，因此现在front和rear都同时指向地址3.     

##### 顺序队列的特点：
- 第一点：    
静态分配存储空间；     
在上面的示例中，当我们把ABC三个数据元素存入队列的时候，顺序队列静态的为每个数据元素分配的存储空间，其中为A分配的存储空间为地址0，为B分配的存储空间为地址1，为C分配的存储空间地址为3；因此，当A进行出队操作，B和C的位置没有发生变化；因此，可以看出顺序队列的第一个特点就是静态分配存储空间；     
- 第二个特点：      
入队操作只能在队尾，出队操作只能在队首；     
顺序队列的这个特点是所有队列的特点；因为前面介绍过队列的定义，队列是只允许在一端进行插入而在另一端进行删除运算的受限制的线性表；因此，顺序队列入队操作只能在队尾，出队只能在队首；      
- 第三个特点：     
队列为空时，` front==rear`；    
在刚才的示例中，当我们开始创建一个空队列时，front和rear同时指向的是地址0.因此，`front==rear`，此时队列为空；而当我们把所有的数据元素从队列中做出队操作完成之后，也就是B和C也进行出队操作之后，此时front和rear同时指向队列的地址3，此时队列也为空队列；因此，顺序队列为空时， `front==rear`；      
- 第四个特点：        
队列为满时， `rear ==` 队列长度 -1；     
当我们把ABC三个数据元素插入队列长度为4的顺序队列当中，rear指向队列地址3， 3==队列长度-1；因此，队列为满时， `rear ==` 队列长度 -1；    
- 第五个特点：
队列非空非满时， front<rear<队列长度-1    

##### 顺序队列的特点：
- 第一点：   
静态分配存储空间；    
- 第二个特点：  
入队操作只能在队尾，出队操作只能在队首；      
- 第三个特点：     
队列为空时， `front==rear`；       
- 第四个特点：   
队列为满时， `rear ==队列长度 -1`；    
- 第五个特点：    
队列非空非满时， `front<rear<队列长度-1`     

### 链式队列：
队列的链式存储结构称为链式队列；    

大家都做过火车，链式队列的结构就非常像我们出行时坐的火车；火车是由一节一节的车厢连接起来的，而链式队列也是由一个一个节点连接起来的。火车的前一个车厢通过一个专门的连接挂件连接到后一个车厢上，而链式队列也是一样，它的每一个节点都有一个指针域next指向后继节点。链式队列其实就是遵循队列操作规则的链式存储的线性表。

##### 注意两点：
- 第一：
它遵循队列操作规则；   
- 第二：
它的存储结构是链式存储结构；

#### 链式队列特点：
- 第一：
链式队列动态分配空间；     
因为链式队列的物理存储次序跟逻辑次序是没有关系的，因此队列的元素在内存中分配的存储空间是动态的，所以链式队列的特点之一就是动态的分配存储空间；
    
- 第二：
入队操作在队尾进行，出队操作在对头进行；     
所有队列都有一个规则，就是从一端进行插入操作，另一端进行删除操作；      
因此链式队列的入队操作只能在队尾进行，出队操作只能在队头进行；     

- 第三：
链式队列在入队时无队满情况；     
这个是链式队列和顺序队列的区别；    
顺序队列有队满的情况，而链式存储结构的队列，是没有队满的情况的，实际上这是根据链式队列存储结构的特性来决定的；因为它的存储结构是链式的，也就是它每个节点都有个next指针域，指向下一个节点，那么我有一个队尾节点，队尾节点同时又一个next指针域，它的指针域是存的是一个空值，因为它已经没有后续节点了；     
那么我们如果要新加一个节点，我们只需要把当前队尾节点的next指针域指向我们新加的数据元素；同样的，我们新加了这个数据元素，它的next指针域设置为空；那么就给这个链式队列新加了一个数据元素，也就是作了入队操作，因此我们可以进行无限制的入队操作，因此链式队列的特点就是无队满的问题；       
- 第四：
链式队列为空的条件： `front==rear`    
因为front和rear分别指向了队头节点和队尾节点，那么如果队列为空，也就是front节点和rear节点分别代表了队头节点和队尾节点；空队列的队头节点和队尾节点都是一个节点，所以 `front==rear`；    


##### 食堂排队打饭的案例：
通过程序来实现食堂排队打饭操作；    
案例的需求：     
排队打完饭的同学就要离开队列，而新来的同学就要站在队尾等待；   
这个案例实现了前面队列操作的接口；      

## 递归：
递归的定义：    
递归是指在定义自身的过程中又直接或间接调用自身的一种算法；        

递归算法由两个要素组成：递归调用和递归终止条件；   
定义自身的过程当中，又直接或间接地调用自身，这种自己调用自己被称为递归调用。    
那么，递归终止条件是递归算法的另外一个元素，也是一个必不可少的要素；     
因为，如果一个递归算法，它实现了递归调用，也就是在定义自己的过程当中，又直接或间接地调用了自己，但是它没有递归终止条件，那么递归调用就无限的循环下去；因此这个算法就成为了一个死循环；       
所以，递归算法要有两个要素来组成，第一是递归调用，要有递归调用的算法才会称为递归算法；同时还要有递归终止条件，这两个是递归必不可少的两个要素；      
递归作为一种算法，在程序设计语言中应用是非常广泛的；采用递归编写程序能使程序变得简洁和清晰；        

在实际应用中，什么样的问题可以使用递归算法来解决呢？    
#### 递归问题的特点：
- 第一点：
一个问题可以被分解为若干层简单的子问题；     
- 第二点：
子问题和其上一层问题的解决方案一致；     
- 第三点：
外层问题的解决依赖于子问题的解决；    

那么只要问题符合这三点，我们就可以用递归算法来解决；    

#### 递归解决的问题：
举例：   
n的阶乘    
n的阶乘就是`n*(n-1)!`    

第一个解决方案： 使用循环的迭代算法；       
```java
public static int factoria(int n) {
 int value=1;
 while(n>0) {
  value* =n--;
}
return value;
}
``` 

第二个解决方案：使用递归算法解决N的阶乘；        
n的阶乘用递归实现的主要原理是用 `n*(n-1)!`来实现的。
```java
public static int recur(int n) {
 if(n==0)
  return 1;
 else
   return n*recur(n-1);
 }
```

递归算法所能解决的问题都是一个问题可以分割为使用相同算法解决的若干子问题。使用递归算法有两个要素需要注意：    
第一个是至少有一个停止条件，不能无限递归下去，那就是死循环了。第二是要计算递归方法的当前值，需要重复调用自身，直至达到停止条件；      

##### 递归的工作方式是：
一个对象函数调用自己的复制品，复制品再次复制出一个复制品继续调用，一直继续下去，直到遇到某个条件停止循环，然后逐层返回；    

举例：     
```
Fibonacci(斐波那契)数列；
Fibonacci(斐波那契)数列的特点是数列中的每一项都是前两项的（最前两项都是1）和，即 F(n)=F(n-1)+F(n-2)  
看视频；
```
一般的线性表、树中，数据在结构中的相对位置是随机的，也就是说和数据的关键字不存在确定的关系，在结构中查找一条数据时需要进行一系列和关键字做比较的工作，这种查找建立在“比较”的基础上，查找的效率与比较的次数密切相关。       
实际上在对数据的查找，我们希望能直接找到我们想要的数据，因此必须在数据的存储位置和数据的关键字之间建立一个确定的对应关系，使得每个关键字和结构中的一个唯一存储位置对应。而在查找时，只需根据这个对应关系，找到给定值的位置，从而找到我们所需的数据，并且这样不再需要进行比较。    
这个对应关系被称为哈希函数。按这个思想建立的表被称为哈希表。     

### 哈希表：
哈希表(Hash table,也叫散列表)，是根据关键码值(Key value)而直接进行访问的数据结构。    
也就是说，它能够通过把关键码值映射到表中一个位置来访问数据，那么这样就可以加快查找的速度。
哈希表就像我们常用的中华字典，我们拿中华汉字来查找某个汉字，来比喻一下使用哈希表。     
我们要查找某个字的时候，首先我们要根据这个字的读音，在字典的前面读音表我们可以查找这个字，并且我们找到这个字之后，它在读音表里表明了这个字在字典里解释的具体的页码，然后我们根据页码就可以在字典里找到这个字的详细信息。     
哈希表也是这个原理；       

哈希表将所有数据元素分布在一串被称作桶的线性表中，并且还有一个散列分布的关键字集合，它以关键字K为自变量，通过一个确定的方法hash()方法来进行计算，hash()方法返回对应的值hash(K)，这个值是一个存储单位的地址，它指向线性表T的索引，从而它可以确定一个数据元素。         
比如现在我们通过关键字K1可以在桶中找到位置h(k1)，那么同样通过关键字k3也可以在桶T中找到位置h(k3)，从而得到对应桶中的数据元素信息。      
哈希表存在两个关键字同时指向一个桶的同一个位置的情况，比如关键字k2和k5通过hash()方法，得到的桶的存储地址相同，因此它们找到的数据元素也相同。       
##### 关键字（也叫键）的作用就是：
它的作用就是用于通过哈希函数计算查找到数据元素具体某个数据项的存储地址，哈希方法就是将关键字与该数据元素的存储位置建立对应关系的方法，将关键字映射为线性表的存储地址索引。    

构建哈希表方法      
哈希表的选择标准：        
```
简单
均匀
```
一个好的哈希方法，对于给定的若干个关键字，其映射地址集合中任何一个地址的概率应该是相等的。换而言之，一个关键字经过哈希方法映射到存储地址应该是随机的，那么以便使得一组关键字的哈希地址均匀的分布在整个地址区域间，从而减少冲突。    
因此，哈希方法的选择标准有两个，一是简单、二是均匀。     
##### 哈希表的常用方法：
```
直接寻址法
数字分析法
平方取中法
叠加法
除留余数法
```

- 直接寻址法    
直接寻址法就是取关键字的某个线性函数来作为哈希地址的构造方法。    
直接寻址法用一个线性函数对关键字进行操作，其结果值作为哈希地址，那么这个关键字的这个线性函数就是哈希地址的构造方法，这个线性函数可以是：
```    
h(key) = a*key +b   
其中，a和b均为常数，key为关键字。    
`a*key +b 是一个线性函数，h(key)就是哈希地址；
```
- 数字分析法
数字分析法是取关键字中某些取值较分散的数字位作为哈希地址。它适用于所有关键字已知的情况。也就是说，所有的关键字已经知道了，我们才能够分析出哪些数字位取值较分散，因此我们找到这些取值较分散的数字位来作为哈希地址；   
举例：   
一组关键字为`(9202 9275 9228 9334 9316 9338 9362 9320)`     
通过分析我们可以发现，每个关键字的第1、2位取值比较集中，因此前两位不宜作为哈希地址。     
这一组关键字前两位实际上就两类，92和93，因此前两位不宜做哈希地址，剩余两位取值比较分散，因此可以根据实际需求取其中若干位作为哈希地址。     
比如，现在可以取最后两位作为哈希地址，来构造哈希表。     

- 平方取中法
平方取中法就是取关键字平方的中间几位作为哈希地址的方法。   
具体取多少位，视实际需求而定。        
一个数平方后的中间几位和数的每一位都有关，由此可知，用平方取中法得到的哈希表地址同关键字的每一位也都有关系，使得哈希地址具有非常好的分散性，     
平方取中法适用于关键字中每一位都不够分散，或者较分散的位数小于哈希地址所需要的位数情况（有分散的位数，但是位数不够用）。      
比如前面讲数字分析法的时候，假如去掉最后两位。关键字只留前面两位，那么前面两位就不够分散，显然数字分析法已经不能用了，因此我们就可以对其关键字进行平方操作，然后取平方后的数的中间分散的几位作为哈希地址，这就是平方取中法；      

- 叠加法
叠加法是首先将哈希表中的关键字分割成位数相等的几段，然后将他们叠加求和，将叠加求和后的值作为哈希地址的方法。      
叠加法适用于关键字位数较多，哈希地址位数较少，而且每位关键字分散都比较集中的情况。    

- 除留余数法
`h(key) = key % p       p为正整数`     
除留余数法是将哈希表中的关键字除以某个整数p的余数作为哈希地址的构造方法；    
整数p通常小于哈希表长度，且接近哈希表长度。     
哈希方法的一般形式为：     
```
h(key) = key % p       p为正整数
```

冲突         
当两个不同的键，由于哈希方法返回的值相同，因而被映射到表的同一位置上；        

比如，我们有两个数据元素，数据元素1和数据元素2，数据元素1有一个键，由于哈希方法返回的值，它被映射到了表的一个位置上，因此数据元素1就被存到这个位置上。现在数据元素2也有一个键，由于哈希方法返回值，根据这个键，哈希方法返回值，返回到同一个位置上，返回的值和数据元素1返回的值相同，因而它也被映射到表的这个位置上，假如我们把数据元素2也存到这个位置的话，那么它就会覆盖数据元素1；因此，就会产生处理冲突。        

一个好的哈希方法能减少冲突，但是不能彻底地避免冲突。    
冲突发生以后，必须寻找下一个可用的地址来处理冲突，    
##### 常用的处理冲突的解决方法有：    
```
开放寻址法
再哈希法
链地址法
```
- 开放寻址法   
开放寻址法是指发生地址冲突时，按照某种方法继续探测哈希表中的其他存储单元，直到找到空位置为止。根据探测步长的不同，开放寻址法分为线性探测和二次探测等。   
此方法的哈希方法如下：    
```
h(key,i) = (h(key) + i^n) % m        i = 0,1,2,....m-1
```
其中，m为哈希表的长度，i为寻址的步长，当n=1时为线性寻址，也叫线性探测法；   
线性寻址方法的优点是只要哈希表未满，就一定能找到一个不冲突的哈希地址，   
因为，这个哈希方法的构造函数`h(key,i) = (h(key) + i^n) % m` ，当n=1时，就是：`h(key,i) = (h(key) + i) % m`      
那么，这个函数实际上 i从0到m-1；      
i等于0的时候就是` h(key)%m`,i等于1的时候就是`(h(key)+1)%m`,    
这样一直遍历下去，一直到m-1，那么实际上它把整个哈希表都遍历完了。因此线性寻址法只要哈希表未满，就一定能找到一个不冲突的哈希地址。     
它的缺点就是容易产生数据元素聚集的现象。      

### 再哈希法
再哈希法是指在用哈希方法计算哈希地址时，准备两个以上的哈希方法。当前一个哈希方法发生冲突时，继续用下一个计算哈希地址，直到没有冲突为止。     
该方法虽然不会像开放寻址法那样产生聚集，但是却增加了计算时间。     

#### 链地址法
链地址法也叫拉链法，它与开放寻址法对应，当遇到冲突之后，它不是按某种算法继续查找下一个不冲突的位置，而是把映射到同一个地址的所有元素（即冲突元素）放在一个链表中，哈希表的的相应位置只保存一个指向这个链表头节点的指针。     
比如，两个键值根据哈希函数得出的位置都是5位置，那么就把两个键值的元素放在一个链表中，比如b0和b1，然后在哈希表中的5位置存放一个指针，这个指针指向这个链表，指向这个链表的头结点。那么这样的方法就是链地址法，也叫拉链法；      

##### 哈希表的查找：
哈希表的查找过程与哈希表的创建过程基本一致。     
对于给定的关键字，值v，按照构造哈希表时设定的哈希表方法求得哈希地址。           
如果该哈希地址存在一个数据元素，而且这个数据元素的关键字的值也等于v，那么哈希表的查找成功了。如果不等于v，则根据构造哈希表时设定的冲突处理方法求得下一个哈希地址，重复上述过程，直到找到的哈希地址中数据元素为空或者数据元素的关键字的值等于v为止。如果得到哈希地址中数据元素为空，则查找失败；如果得到的哈希地址中数据元素的关键字的值等于v，则查找成功。      
现在假设哈希函数是 `H(key)=key%11`.         
在我们创建哈希表的时候我们在关键字是16和关键字是27的两个位置，我们要插入值b0和b1，根据哈希函数是有冲突的，`16%11==5  27%11==5` ；        
因而我们采用链地址法解决了冲突，把b0和b1存储在了一个链表中；      

现在我们要进行查找操作了；             
假如我们要查找关键字是27的值，首先根据哈希函数，我们找到了位置5，它指向了一个链表，因此我们需要循环这个链表，当循环到第一个位置的时候，我们发现的值不为空，发现的值是b0，而b0的关键字是16而不是27，因此继续循环，再次找到了b1，而刚好b1的关键字是27，到此，完成查找；这就是哈希表的查找。它与哈希表的创建过程基本一致。      
