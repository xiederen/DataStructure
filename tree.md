
# 非线性数据结构：树和图；    
树用来表示分层的数据结构，图经常用来表示类似于交通图的数据结构；    
## 非线性数据结构的特点： 
在非线性数据结构当中，每个节点的直接前趋节点和直接后继节点都可能不止一个；比如，在树中，有的节点就可能存在多个直接后继节点；

## 树：
树是一种重要的非线性数据结构。它是由n(n>0)个节点组成的有限集合。    
在数据结构当中，树就是由现实当中的树抽象而出来的这么一种数据结构；     
在数据结构当中，我们把树的各个部分抽象为节点，也就是说树是由N个节点组成的有限集合。其中这个N是大于等于0的正整数。        
当N等于0时，树中不包含任何节点；对这种不包含任何节点的树，称之为空树；即： n=0 时， 称为 空树       
而当N大于0时，那么这棵树当中至少包含了1个节点，这个时候，树顶端的节点称之为 树的根 或 根节点，每棵非空的树有且只能有一个根节点；       

在一棵树当中，除了根节点之外，剩余的节点可以分为若干个集合，而且这些集合没有交点，也就是说它是互不相交的；      
例如，在一棵树当中，去掉根节点，那么剩下的节点可以分为两个互不相交的子集；在这些子集当中，它每个子集本身又构成了一个树，称这些树为根节点的子树；即：      
除根之外，其余节点可分为若干个互不相交的子集，每个子集本身又是一棵树，称为根的子树；       

在一棵树当中，一个节点往往拥有若干个子树；     
我们就把这个节点拥有的子树的数量称之为这个节点的度；       
在一棵树的所有节点当中往往包含了很多度数为0的节点，我们就把这些度数为0的节点称之为叶子节点或者叶子；       
在一棵树当中，既然节点是有度数的，树也是有度数的；       
在一棵树当中，所有节点的最大度数我们就称之为这棵树的度；        

所有节点的数量之和等于所有节点度数之和再加上1；        
在一棵树当中，一个节点的度数总是对应它下面的一个节点，但是没有度数对应根节点，所以说在一棵树当中，所有节点的数量之和等于所有节点度数之和再加上1；        

节点的层反映该节点在树的位置；         
在一个树当中，我们约定根节点的层数为0，而其他节点的层数都是其父节点的层数再加上1；     
一个节点的层数大于0，则该节点不是根节点；     
在树中任意一个层数为`K(K>0)`的节点B都有一个层数为K-1的节点A与之对应，B称为A的孩子或者子节点，A称为B的双亲或者父节点；     
在一棵树当中，一个节点最多只能有一个父节点，但可以有多个子节点；      

在树当中，同一个节点的子节点互称为兄弟(sibling)；          
如果两个节点的父节点不同，但是它们在同一个层次上，那么它们互称为堂兄弟；   

在树当中，各个节点之间的连线称之为树的边；     

在树当中，一个节点移动到另外一个节点所经过的节点的序列，称之为路径；   
从一个树的根节点到树当中任意的其他节点，总是只存在唯一的路径。     
路径的长度描述了节点的层数；也就是说，一个节点到根节点，或者说一个节点到另外一个节点的长度是多少；        
在树当中，从根节点出发，到树当中叶节点的最长的路径的长度称之为树的高或者深；      

在一棵树当中，如果所有节点的子树从左到右都是有次序的，那么我们称这棵树为有序树；    
度数为m的有序树称为m叉树，这个m叉树有两个要素：      

- 第一个要素：   
这棵树的度数要为m；     
也就是说在这棵树当中所有节点的度数最大是m；    
- 第二个要素：    
这棵树是一棵有序树；    

在数据结构当中，森林是指N个互不相交的树的集合；    

在数据结构当中，树和森林是可以相互转换的；     

## 二叉树：
每个节点的度数均不超过2的有序树称为二叉树；      
二叉树有两个要素：         
- 第一个：
在这个二叉树当中，所有节点的度数均不能超过2；     
- 第二个：
这棵树要是一棵有序树；    
### 二叉树的特点：
- 第一：
在二叉树当中，每个节点最多有两个子节点，度数最大为2；     
- 第二：
节点的子树有左右之分；    
由于二叉树是一个有序树，因此在二叉树当中，节点的子树从左到右是有次序的，左边的子树称之为左子树，右边的子树称之为右子树；    
- 第三： 
在二叉树的第i层上最多容纳2的i次方个节点；     
- 第四：
如果一个二叉树叶节点数量为n0，度数为2的节点数量为n2，则： `n0=n2+1`        
- 第五：
高度为`H(H>=0)`的二叉树最多有 `2^(H+1)-1` 个节点;   

在二叉树当中的某一层上，最多能容纳多少个节点：      
总结：    
```
第零层，只能容纳一个节点，根节点；
第一层，做多容纳两个子节点；
第二层上，做多容纳4个子节点；
第三层上，做多容纳8个子节点；
```
得出结论：    
**在二叉树的第i层上最多容纳2的i次方个节点；**

如果在一棵二叉树当中，叶子节点的数量为n0，也就是说度数为0的节点数量为n0，度数为2的节点的数量为n2，那么n0和n2之间的关系为：    
我们假设此二叉树总的节点数为n，度数为1的节点数为n1，那么就存在一个等式`n=n0+n1+n2`；      
在一棵树当中，节点的数量之和总是等于所有节点的度数之和再加上1；      
即：` n=1*n1+2*n2+1`     
由这两个等式，得出： `n0=n2+1`；   

在一棵高度为h的二叉树当中最多能容纳多少个节点：     
在二叉树当中的每一层，如果它容纳的节点数量都达到最大值的话，那么这棵二叉树当中容纳的节点数量也就达到了最大值了；       
在二叉树的第i层上最多可以容纳2的i次方个节点，此时高度为h的二叉树中应该有多少个节点呢？     
将这些节点从第0层一直加到第h层；      
第0层是2的0次方；     
第一层是2的1次方；       
这样加下去，一直加到2的h次方；       
即：    
```
2^0 + 2^1 + ..... + 2^h   
```
结果是： ` 2^(h+1) -1`     
所以：高度为`H(H>=0)`的二叉树最多有 `2^(H+1)-1` 个节点;    

那么满足此条件的二叉树称之为 满二叉树 ;      
也就是说，此时二叉树当中所有的节点都有两个子节点；       

在满二叉树当中，在最下层，从右向左，连续删除若干个子节点，称这棵二叉树为完全二叉树；   

##### 满二叉树和完全二叉树之间的关系：
满二叉树除了叶子节点之外，所以其他的节点都是满的，都有两个子节点；       
即：在一棵高度为h的二叉树当中，如果它的节点数量达到了2的(h+1)次方-1个；     
那么此时这棵二叉树就称之为满二叉树；      
如果我们在一棵满二叉树的最下层，从右向左连续删除若干个叶子节点，此时形成的二叉树称之为完全二叉树；       
在删除叶子节点之前，满二叉树是一棵完全二叉树；     
当我们删除若干个叶子节点以后，所形成的完全二叉树就不一定是一棵满二叉树了；      
也就是说，一棵满二叉树肯定是一棵完全二叉树，而一棵完全二叉树就不一定是一棵满二叉树，这就是它们之间的区别和联系。      


###   二叉树的存储结构：
线性表、队列、栈等数据结构的存储结构分为：顺序存储和链式存储。   
顺序存储利用一组连续的存储单元存放这些数据元素。    
链式存储用指针指向相关数据元素，那么二叉树的存储结构为：     
类似的，我们也可以用顺序存储和链式存储结构，去存储二叉树当中的数据元素；    
#### 顺序存储：
顺序存储结构就是利用一组连续的存储单元，来存放二叉树当中的所有节点；   
顺序存储结构的优点就是存储非常方便，而且能够用序号随机访问二叉树当中的所有节点。     
但是在二叉树存储结构当中顺序存储只适合于满二叉树和完全二叉树。     
因为对于其他的二叉树会造成不同程度的资源浪费；     
首先来看一下满二叉树和完全二叉树的顺序存储结构；     
对于满二叉树和完全二叉树来讲，可以逐层把所有的节点放到一组连续的存储单元当中；比如说，我们存储到一个数组当中；      
在满二叉树和完全二叉树当中，所有的节点都是左右有序的，并且在满二叉树当中一个节点或者有两个子节点或者它是叶子节点；而一个完全二叉树，它是在满二叉树的基础上的最下层，从右向左，依次删掉若干个叶子节点构成的，我们依据满二叉树和完全二叉树这个特点，就可以根据这个节点的序号快速的定位到这个节点及其父节点，左右孩子节点的存储位置。      

下面我们就以一维数组为例，来看一下二叉树的顺序存储。       
在完全二叉树当中，我们把二叉树当中编号为i的节点，存放到数组的第i个元素当中，那么编号为i的父节点以及i的左右子节点都分别常常在数组的什么位置呢？          
以节点3为例，在这样一个完全二叉树当中，如果我们把所有的节点逐层依次存放在一维数组当中，也就是说，把根节点0放在一维数组的第一个元素，根节点的子节点1放在一维数组的第二个元素，根节点的另外一个子节点2存放在第三个位置当中去，依次类推，节点3存储在数组的第4个位置，节点3的父节点1存放在第2个位置，节点3的子节点节点7和节点8分别存放在分别存储在第8个位置和第9个位置；所以得出结论：         
如果把完全二叉树的第i个节点存放在数组的第i元素当中，那么它的父节点存储在第(i/2)个位置，左孩子存放在第(2i)个位置，右孩子存储在第(2i+1)个位置；      
如果i是奇数的话，则(i/2)直接去掉小数位取整；        

既然满二叉树和完全二叉树的顺序存储结构有这样一个规律，我们就可以依据这个规律去访问满二叉树或者完全二叉树当中的所有节点在数组当中的存储位置；    
但是如果一棵树既不是满二叉树也不是完全二叉树，我们如何在数组中存储树当中的所有节点，才能保证方便地找到每个节点的存储位置呢？         
比如：  `0 -> 2 -> 6`    
如果把节点 `0 2 6` 依次存储在数组的第一个位置，第二个位置和第三个位置，那么父节点和子节点的存储位置之间就没有规律可言；这时，我们就需要用“空节点”将一棵二叉树补成一棵完全二叉树；然后再使用顺序存储。        
就像这棵二叉树一样，在这棵二叉树当中，只有3个节点，所以我们就需要在根节点0的左边补上左孩子，这时候，它仍然不是一棵完全二叉树；所以我们仍然需要为0的左孩子补上两个子节点，根节点的右孩子2也需要补上左孩子；     
这时候形成的二叉树才是一个完全二叉树；       
但是，在我们生成的完全二叉树当中，我们为了实现顺序存储，需要用到7个存储单元；也就是说，我们为了存储3个数据元素，占用了7个存储单元；而在这7个存储单元当中，第`2,4,5,6`位置存储的都是空节点；所以我们说就造成了其他资源的浪费，这就是顺序存储的缺点；     


#### 二叉树的链式存储结构：
与顺序存储不同，二叉树的链式存储结构描述数据元素之间的关系，它不是存储地址的相对位置而是指针。    
线性表的链式存储结构的基本单位是节点；    
在线性表的节点中，一共有两个域，分别是：数据域和指针域；    
与线性表的链式存储类似，二叉树的链式存储的基本单位也是节点，不同的是在二叉树的节点中，包含了三个域，分别是数据域(Data)、左孩子域(Lchild)和右孩子域(Rchild)。     
其中，数据域存放数据元素，左孩子域存放指向左孩子节点的指针，右孩子域存放指向右孩子节点的指针。        
由此节点构成的二叉树的链式存储结构称为二叉链表；    

### 遍历二叉树：
在我们学习如何去遍历二叉树之前，首先要搞清楚一个概念；   
那就是什么叫二叉树的遍历；   
二叉树遍历的定义：      
二叉树的遍历就是指以某种特定的次序访问二叉树中的所有节点，并且使每个节点恰好只被访问一次。     
注意两个要素：         
- 第一：
访问二叉树当中的所有节点；也就是说所有节点都要访问到；    
- 第二：
每个节点恰好只被访问一次，而不能重复访问；    

如果一棵二叉树没有任何节点，它就是一棵空树，对它的遍历就无从谈起；    
所以在这里我们讨论的遍历方法都是指二叉树不为空的这种情况；     
二叉树是一种有序树；      
也就是说在二叉树当中子节点的左右子树都是有序的；     
根据访问二叉树当中节点的先后次序，我们可以把二叉树的遍历分为三种方式：      
##### 二叉树的遍历分为：
```
先序遍历；
中序遍历；
后序遍历；
```
其中，先序、中序、后序都是针对根节点来说的；      
也就是说，先序遍历的时候，我们首先访问的是根节点；     
在中序遍历的时候，我们中间访问根节点；      
后序遍历，就是最后访问根节点；    

##### 先序遍历：
先序遍历的意思就是在遍历过程当中，我们分为三个步骤：
```
首先访问根节点；
然后先序遍历根节点的左子树；
最后先序遍历根节点的右子树；
```
注意：    
**在这三个步骤当中，后面两个步骤都有先序两字，它们的意思就是说在遍历根节点的左子树和遍历根节点的右子树的时候，也要遵循一个规则，就是我们在访问左子树和右子树的时候，也要遵循先序原则；**

##### 中序遍历：
同先序遍历非常类似，二叉树的中序遍历也分为三个步骤：
```
首先中序遍历左子树；
然后访问根节点；
最后中序遍历右子树
```
注意：    
**在这三个步骤当中，第一个步骤和第三个步骤都有中序两个字，也就是说我们在遍历左子树和遍历右子树的时候，也要遵循中序的原则；而根节点的访问是放在中间的；**


##### 后序遍历:
后序遍历就是我们遍历这个二叉树的时候，最后才访问二叉树的根节点，那么在访问它的根节点之前，要先访问这棵根节点的左子树和右子树；    
那么我们在访问根节点的左子树和右子树的时候，也要遵循后序访问的规则；    
也就是说，我们在访问左子树和右子树的时候，同样，是先遍历左子树，然后遍历右子树，最后才访问根节点；     
后序遍历的步骤：     
```
首先后序遍历左子树；
然后后序遍历左子树；
最后访问根节点；
```

## 图：
图的定义：    
 图是一种重要的非线性数据结构，它由非空的顶点集合和一个描述顶点之间相互关系（边）的有限集合组成。图可以用二元组定义为：    
`G = (V,E)`    
其中：G表示一个图，V表示图中顶点的集合，E表示图中边的集合。   
上面学习了树的相关概念和术语以及二叉树的存储结构，以及如何遍历一棵二叉树；下面就学习另一种重要的非线性数据结构 ---  图         
图是除了树之外另外一种非常重要而且非常有用的非线性数据结构。       
图在日常生活中最常见的形式是交通图；     
在数据结构当中，图包含一个非空的顶点集合，和一个描述顶点之间相互关系的有限集合；这个表示顶点之间的相互关系的集合称之为图的边。        
在图中如果每条边都是没有方向的，那么称这个图为无向图；     
相反，如果图中每条边都是有方向的，则称为有向图；       
在图中，顶点的度是指起源于该顶点的边数。       

### 路径：
图： `A E B D C` 依次首尾相连，形成一个闭合回路；       
顶点A到顶点D的路径是指，从顶点A出发经过图中其他的顶点以及边，到达顶点D的一个顶点序列，并且在这个顶点序列当中，任何相邻的两个顶点之间都要有边相连。       
从顶点A到顶点D之间，有两条路径，分别为： `A E B D` 和` A C D`    
#### 路径的定义：
顶点V1到顶点Vn的路径是指顶点序列`V1 V2 V3...Vn`,其中`(V1,V2) (V2,V3) (V3,V4)...(Vn-1,Vn)`均为图中的边      

路径上边的数量称为路径的长度；       
例如，从顶点A到顶点D的两条路径，长度分别为3和2；     

在图中，截取顶点和边的一部分就构成了这个图的子图；    
也就是说，在子图中顶点的集合是原图的当中的顶点集合的子集；   
子图当中边的集合是原图当中边的集合的子集；    


在图中，如果从一个顶点到另外一个顶点之间有路径，则称这两个顶点是连通的；     
任意的两个顶点都是连通的图称为连通图；     
在无向图中，它的极大连通子图称为这个图的连通分量。     

在实际应用当中，如果我们只知道两个顶点之间是否连通的，往往是不够的；    
在实际应用当中，边除了表示顶点之间是否存在联系以外，往往还表示一定的实际意义，通常会有一个实数与它相关，比如说一条路径的长度或者花费的时间等等；     
这个实数称之为 权；       

边上带有权值的图称为带权图，或者，网络；    

### 图的存储结构： 
在学习了图的定义以及术语之后，一起来学习图的存储结构。   
线性表的存储结构分为线性存储和链式存储两种；   
`树的存储结构也分为线性存储和链式存储。`   
但是在图的存储结构当中，不分为顺序存储和链式存储两种；    
因为在图当中任何两个顶点之间都可能存在联系。我们无法确定一个唯一的第一个顶点，在图中哪一个是它的第一个顶点，并且在第一个节点之后，它的后继节点和前趋节点是哪一个。都是不好确定的。    
因此我们就无法用顺序存储结构来描述数据元素之间的相互关系。      
也就是说，在图当中，不存在顺序存储结构。           
那么我们用什么存储结构来存储一个图呢？        
在用一个存储结构存储图的时候，我们不但存储图的所有顶点，而且要存储顶点之间的相互关系。也就是图中的边。那么我们用什么结构来描述图的顶点以及顶点的相互关系。     
在以前学习的知识当中有没有这种合适的结构呢？        
比如说数组，在我们以前讲解线性表和树的存储结构的时候，顺序存储都可以用一维数组。但是，图，用一维数组显然是不够的。因为一维数组只能存储各个节点。而我们需要各个节点以及它们之间的相互关系。使用二维数组是可以的。       
除了二维数组，图还有哪些存储结构呢？       

#### 图常用的存储结构有：
```
邻接矩阵  也叫数组表示法，它用来表示图中顶点之间的邻接关系
邻接表
十字链表
邻接多重表
```
重点讲解邻接矩阵的存储方式；     
##### 邻接矩阵：
邻接矩阵也叫数组表示法，它用来表示图中顶点之间的邻接关系。   
它是一个二维数组。     
如果图中有n个顶点，那么它的邻接矩阵就是一个`n*n`的二维数组。     

邻接矩阵是如何存储图的所有顶点以及顶点之间的所有关系呢？     
我们知道图分为两种，    
```
一种是无权图；在这种图中，它描述了不同两个顶点之间是否是相连的，它并没有权值。
一种是有权图。图中的边不仅表示顶点之间的连通关系，而且还有一定的实际意义。
```
##### 无权图的邻接矩阵存储方式：
对于无权图来说，如果两个顶点之间是有边相连的，我们要在矩阵的相应位置记作1，表示这两个顶点之间是相连的；如果这两个顶点之间是没有边相连的，也就是没有连通的，那么记作0；    
因此，在无权图的邻接矩阵中，它只包含两个值0和1；      
举例：    
`A E B D C `依次首尾相连形成一个闭合回路，A和C相连；       
用邻接矩阵表示：     
```
    A    B    C   D    E
A   0    0    1   0    1

B   0    0    0   1    1

C   1    0    0   1    0

D   0    1    1   0    0

E   1    1    0   0    0
```


#### 有权图的邻接矩阵：
如何用矩阵来表示有权图：     
在这个矩阵当中，我们不仅要表示顶点之间的连通关系，而且还要表示边的权值。 那么，该如何表示呢？      
在一个有权图当中，如果两个顶点之间是有边直接相连的，那么在邻接矩阵的相应位置记录该边的 权值，而不是1；        
在有权图当中，如果两个顶点之间是没有边直接相连的，如果表示为0，容易混淆，不知是表示权值是0，还是没有连通。因此，      
在有权图当中，如果两个顶点之间是没有边直接相连的，则记作无穷大符号(∞)，而不是0。一个边的权值为无穷大，就是说这个边的长度为无穷大，或者说从这条路径走下去，花费的时间是无穷大，没有边相连的；       
即：        
在一个有权图当中，如果两个顶点之间是有边直接相连的，那么在邻接矩阵的相应位置记录该边的权值，而不是1；     
在有权图当中，如果两个顶点之间是没有边直接相连的，则记作无穷大符号(∞)，而不是0。      
举例：    
```
顶点 A B C D E  
边  A-E E-B B-D D-C C-A
权值：  A-E为12  E-B为8 B-D为23 D-C为15 C-A为26
```
##### 有权图的邻接矩阵表示：
```
    A    B    C   D    E
A   ∞    ∞   26   ∞   12

B   ∞    ∞   ∞    23   8

C   26   ∞   ∞    15   ∞

D   ∞   23  15    ∞    ∞

E   12  8   ∞     ∞    ∞
```

#### 图的遍历
在学习如何遍历图之前，先看一下图的遍历的定义；    
定义：    
图的遍历也称搜索。        
与树的遍历类似，遍历一个图的时候也是从某一个顶点出发，按照某种特定的次序对图中所有顶点进行访问，并且使每个顶点恰好只被访问一次。     
也就是说我们既要访问图中所有的顶点，而且每个顶点只能被访问一次，即在访问了一个顶点之后就不能再被访问了。        
##### 遍历一个图的时候，通常有两种方法：
```
深度优先搜索
广度优先搜索；
```
##### 深度优先搜索
深度优先搜索的基本思想：    
深度优先搜索就是在搜索的时候，从一个顶点出发，沿着一条路径一直搜索下去，直到不能前进为止，这个时候再从原来的顶点出发，沿着另外一条路径继续搜索下去； 如果从原来的顶点出发的所有路径都访问过了，还有未被访问过，就再另选一个未被访问的顶点作为起点，继续访问； 直到所有的顶点被访问到；      
这就是深度优先搜索；    

##### 广度优先搜索：
广度优先搜索的基本思想通俗的讲，就是搜索比较近的顶点，搜索完以后，再向外搜索；    
如果从原来的顶点出发的所有路径都访问过了，还有未被访问过，就再另选一个未被访问的顶点作为起点，继续访问； 直到所有的顶点被访问到；       
广度优先搜索中必须要遵循的一个原则：        
要使“先被访问的顶点的邻接点”先于“后被访问的顶点的邻接点”被访问；    
