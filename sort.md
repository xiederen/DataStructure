
# 排序：
计算机中常常将排序理解为一种操作；     
其目的是将一组无序的记录序列调整为有序的记录序列；    
根据待排序的数据元素的数量不同，可以将排序算法分为两类：   
```
内部排序
外部排序
```
#### 内部排序和外部排序的区别：
如果数据元素比较少，排序的过程可以在内存储器完成，我们将这个过程称为内部排序；   
而相反，如果数据元素的数量很大，内存储器不足以完成排序的功能，这时就要借助于外部存储器，称为外部排序；     

本节的排序算法都是针对内部排序的；    
内部排序按照排序过程中依据的原则不同，可以分为：      
```
插入排序
交换排序
选择排序
归并排序
分配排序
等等
```
本节主要讲述插入排序和交换排序；   

### 插入排序：
插入排序的基本思想：   
每次将一个待排序的数据元素，按照其关键字大小插入到前面已排好序的有序序列的适当位置，插入操作完成之后，使插入以后的数据序列仍然为一个有序序列，直到整个序列成为有序序列为止。     

##### 在此类排序算法中，最常用的有：
```
直接插入排序、
折半插入排序、
希尔排序；
```

#### 直接插入排序：
直接插入排序的基本思想：    
假定在1个含有5个元素的待排序序列中，假定第1个元素是1个只有1个元素的有序序列，把从第2个开始直到第5个所有元素，逐个插入到第1个元素所在的有序序列的适当位置，使插入以后的新序列仍为有序序列，从而得到该5个元素按照关键字大小排列的有序序列；     

示例：      
给出一组数据：`23、45、16、7、42`     
现在要求将这组数据按照由小到大的顺序排列并输出结果。    
```
初始关键字 23 45 16 7 42
第一步     23 45 16 7 42
第二步     16 23 45 7 42
第三步     7 16 23 45 42
第四步     7 16 23 42 45
```

直接插入排序代码：      
```java
public static void main(Stirng[] args) {
int[] data={23,45,16,7,42};
int len = data.length;
for(int i=1;i<len;i++) {
  int currentData = data[i];
  int temp = i;
  while(temp>0 && data[temp-1]>currentData) {//向右移动
    data[temp]=data[temp-1];
    temp--;
 }
   data[temp] = currentData;   //交换数据
 }
/*打印输出*/
 for(int x:data)
 {
   System.out.println(x);
 }
}
```
在这段代码中，分别使用了for循环和while循环。    
对于for循环，从i=1开始，也就是将这组数据中的第二个数据开始一直到最后一个数据，分别插入到有序序列中；       
而while循环，用于将每次for循环中的数据和前面的有序序列中的数据进行比较，若大于前面的数据，则直接插入当前的位置，否则将前面的数据后移，并继续比较前一个数据；      
在这段代码的最后，也有一个for循环；在这个for循环当中，我们使用system.out.println来对这组数据进行打印输出。        

### 折半插入排序
折半插入排序算法是对直接插入排序算法的一种改进。    
在直接插入排序算法中，它是向有序序列中插入一个元素，那么插入的位置是把待插入元素关键字与有序序列中的元素的关键字逐个比较得到的。    
##### 折半插入排序算法的基本思想是：  
向有序序列中插入元素，那么插入位置可以不断地平分有序序列，并把待插入的元素的关键字与平分有序序列得到的关键字比较，以确定下一步要平分的子序列，直到找到合适的插入位置为止。    

示例：    
```
待插入元素  45
有序序列    7 16 23 42 45  折半得到23，与45比较得到要平分的子序列42 45
第一步      7 16 23 42 45  折半得到42，与45比较，确定下一步查找方向
第二步      7 16 23 42 45  45 与 45 比较，相等，确定插入位置
第三步      7 16 23 42 45
```
折半插入排序代码       
```java
public static void main(String[] args) {
int[] data={7,16,23,42,45,45};
int len = data.length;
int insertData = data[len-1];  //最后一位为待插入元素
int low=0;
int high = len-2;
while(low <=high) {
   int middle = (low+high)/2;   //计算平分位置
   if(insertData<data[middle])
       high =middle-1;
   else
       low = middle+1;
}
for(int j=len-1;j>high+1;j--) { //向右移动
   data[j] = data[j-1];
}
data[high+1] = insertData;   //插入数据
/*打印输出*/
for(int x:data)
{
  System.out.println(x);
}
```
在代码中，首先需要确定有序序列的最低位和最高位的位置，然后通过最低位和最高位的和除以2来计算出平分位置，接着再通过待插入元素与该平分位置的关键字进行比较，来确定下一步要平分的子序列的位置；     
如果待插入元素小于平分后的平分位置的数据，那么就把最高位等于平分位置的位置减1；相反，如果待插入元素大于平分位置的元素，那么就要把最低位等于平分位置加1；以此类推，最终确定位置后，将待插入元素插入，同时将后面的元素向后移动，从而得出最终的排序后的数据；     

##### 折半插入算法的基本思想：
向有序序列中插入元素，插入位置可以不断的平分有序序列并把待插入元素的关键字与平分有序序列得到的关键字进行比较，以确定下一步要平分的子序列，直到找到合适的插入位置为止。     


### 希尔排序
希尔排序的基本思想：     
先将整个待排序序列分割成若干子序列，每个子序列由相差一定长度的数据元素组成（这个相差的长度称为增量），然后我们分别对这些子序列进行直接插入排序，一轮排序后再取第二个增量，以此类推，需要注意的是，对于希尔排序中增量的确定没有统一的规定，通常的做法是：第一个增量为带排序序列长度的二分之一（取整），然后逐渐减半（取整），直到等于1为止。       
先将整个待排序的序列分割成若干个子序列，每个子序列由相差一定长度的数据元素组成，那么这个相差的长度称之为增量；然后我们分别对各自的子序列进行排序；这样，第一轮结束后，我们再以一定的长度进行分割，分割成不同的子序列，同样对各自的子序列进行排序，此时的增量应该比前一个增量小。这样我们直到最后增量设置为1.我们再进行一次插入排序，这样整个序列的排序就完成了；      
```
初始关键字  23 45 16 7 42
第一步      23 45 16 7 42    增量设置为 3
第二步      7 42 16 23 45    增量设置为2
第三步      7 23 16 42 45    增量设置为1
第四步      7 16 23 42 45
```
希尔排序算法代码       
```java
public static void main(String[] args) {
 int[] data={23,45,16,7,42};
 int temp;
 itn len=data.length;
 for(int k=len/2;k>0;k--) { //增量设置
   for(int i=k;i>len;i++) {
      if(data[i-k]>data[i] { //交换数据
        temp=data[i-k];
        data[i-k]=data[i];
        data[i]=temp;
       }
   }
}
/*打印输出*/
for(int x:data)
 {
    System.out.println(x);
   }
}
```
在这段代码中，主要通过两个for循环来实现希尔排序操作；      
那么首先代码中第一个for循环，也就是外部的for循环，那么通过这个for循环来设置增量值；需要注意的是对于希尔排序中增量的确定没有统一的规定，那么我们通常的做法第一个增量为待排序序列长度的二分之一，取整。然后后续增量逐渐减少，直到等于1为止。那么，这个for循环主要是用来获取增量。       
那么，再通过第二个for循环，第二个for循环来分别对这些子序列进行直接插入排序；注意，在第二个for循环当中，有一个if条件判断，那么在这里如果符合判断条件则进行数据交换；这个if只是用来进行数据交换用的；在我们进行数据交换的时候使用了一个temp临时变量；     
在代码的最后就是打印输出排序的结果；    


## 交换排序
简单的说，利用交换数据元素的位置进行排序的方法称为交换排序。常用的交换排序算法主要有冒泡排序和快速排序。    
- 冒泡排序   
- 快速排序  

### 冒泡排序算法
什么是冒泡排序算法：   
冒泡排序算法的基本思想：      
比较相邻的两个数据元素的关键字，如果它们之间的大小关系与期望的关系相反（称为逆序），则交换该两个数据元素的位置，否则不交换。       

示例：    
```
初始关键字  23 45 16 7 42
第一步      23 45 16 7 42
第二步      23 45 16 7 42
第三步      23 16 45 7 42
第四步      23 16 7 45 42
第五步      23 16 7 42 45
第n步       .......
第n+1步     7 16 23 42 45
```
示例：        
冒泡排序实现一组数据的升序排列，写出程序代码。       
程序代码：       
```java
public static void main(String[] args) {
 int[] data ={3,18,13,9,42,21,31,12};
 int len=data.length;
 int temp;
for(int i=len-1;i>1;i--) {
 for(int j=0;j<i;j++) {
    if(data[j]>data[j+1]) {
	temp=data[j];
	data[j]=data[j+1];
	data[j+1]=temp;
	}
    }
}
for(int x:data)
 {
   System.out.println(x);
 }
```
在这段代码中，包含了两个for循环，这两个for循环是互相嵌套的for循环；        
首先，外层的for循环，也就是外面的这个for循环，用于确定一组元素数据；          
而随着每一轮的比较，这组数据将逐渐减少，这里我们使用的是i--;      
而第二个for循环，也就是嵌套在里面的for循环，它的作用是对当前这组数据中的相邻数据进行比较，并确定是否交换顺序。        
在第二个for循环当中，有一个if条件判断，那么这个就是用于交换数据的；      
在这里我们用一个temp临时变量来帮助我们进行数据交换；        
第一个for循环的第一次执行，也就是说第一个for循环执行一次后，这组数据中最大的数据将位于最后一位；      
那么，接着再执行第二次for循环，也就是最外层的for循环执行第二次；        
以此类推，我们将得到这组数据的升序排列；        

##### 冒泡排序算法的基本思想：
比较相邻的两个数据元素的关键字，如果它们之间的大小关系与希望的关系相反，也就是逆序，则进行交换，也就是交换这两个数据元素的位置；否则，则不交换；    
经过一轮比较之后，那么我们就能得出一个结果，     
比如我们对一组数据要从小到大排列，那么经过一轮比较之后最大的就会放到最后一个位置；    
那么以此类推，我们再来进行第二轮、第三轮直到整个序列完成排序为止；      
